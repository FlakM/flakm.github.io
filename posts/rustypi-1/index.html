<!doctype html><html lang=pl><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><title>Zardzewiała dioda |
FlakM blog</title><meta name=description content="Blog o programowaniu"><meta name=author content="Maciej Flak"><link rel=apple-touch-icon href=/apple-touch-icon.png sizes=180x180><link rel=icon href=/favicon-32x32.png sizes=32x32 type=image/png><link rel=icon href=/favicon-16x16.png sizes=16x16 type=image/png><link rel=manifest href=/manifest.json><link rel=mask-icon href=/safari-pinned-tab.svg color=#0c344b><link rel=icon href=/favicon.ico><link rel=stylesheet href=https://cdnjs.cloudflare.com/ajax/libs/prism/1.17.1/themes/prism-okaidia.min.css><link rel=stylesheet href=/dist/main.37ab3f61b95417873748.min.css><link rel=stylesheet href=/css/./main.css><link rel=canonical href=https://flakm.github.io/posts/rustypi-1/><meta property="og:title" content="Zardzewiała dioda"><meta property="og:description" content="Przez ostatnie kilka lat zajmowałem się programowaniem aplikacji biznesowych. Nigdy nie miałęm okazji uczestniczyć w lekcjach elektroniki. Chęć nauki nowego języka - rust zachęciła mnie do wyciągnięcia z szafy zakurzonej maliny i zbudowania bardziej złożonego układu.
Na początek skrócona lekcja elektroniki. Bardzo polecam dowolną pozycję z ćwiczeniami. Wiedza na temat tego co się dzieje i jak działa prąd zwiększy bezpieczeństwo (nasze i delikatnych układów scalonych) oraz zapewni dużo większą satysfakcję z całego procesu."><meta property="og:type" content="article"><meta property="og:url" content="https://flakm.github.io/posts/rustypi-1/"><meta property="og:image" content="https://flakm.github.io/images/yannick-pipke-GtcA8mw0t1U-unsplash.jpg"><meta property="og:image" content="https://flakm.github.io/images/rystypi/leds/ta%C5%9Bma.jpg"><meta property="og:image" content="https://flakm.github.io/images/rystypi/leds/uk%C5%82ad.jpg"><meta property="og:image" content="https://flakm.github.io/images/rystypi/leds/it-crowd-gif-4.gif"><meta property="article:published_time" content="2020-07-01T14:13:56+02:00"><meta property="article:modified_time" content="2020-07-01T14:13:56+02:00"><meta itemprop=name content="Zardzewiała dioda"><meta itemprop=description content="Przez ostatnie kilka lat zajmowałem się programowaniem aplikacji biznesowych. Nigdy nie miałęm okazji uczestniczyć w lekcjach elektroniki. Chęć nauki nowego języka - rust zachęciła mnie do wyciągnięcia z szafy zakurzonej maliny i zbudowania bardziej złożonego układu.
Na początek skrócona lekcja elektroniki. Bardzo polecam dowolną pozycję z ćwiczeniami. Wiedza na temat tego co się dzieje i jak działa prąd zwiększy bezpieczeństwo (nasze i delikatnych układów scalonych) oraz zapewni dużo większą satysfakcję z całego procesu."><meta itemprop=datePublished content="2020-07-01T14:13:56+02:00"><meta itemprop=dateModified content="2020-07-01T14:13:56+02:00"><meta itemprop=wordCount content="2618"><meta itemprop=image content="https://flakm.github.io/images/yannick-pipke-GtcA8mw0t1U-unsplash.jpg"><meta itemprop=image content="https://flakm.github.io/images/rystypi/leds/ta%C5%9Bma.jpg"><meta itemprop=image content="https://flakm.github.io/images/rystypi/leds/uk%C5%82ad.jpg"><meta itemprop=image content="https://flakm.github.io/images/rystypi/leds/it-crowd-gif-4.gif"><meta itemprop=keywords content><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://flakm.github.io/images/yannick-pipke-GtcA8mw0t1U-unsplash.jpg"><meta name=twitter:title content="Zardzewiała dioda"><meta name=twitter:description content="Przez ostatnie kilka lat zajmowałem się programowaniem aplikacji biznesowych. Nigdy nie miałęm okazji uczestniczyć w lekcjach elektroniki. Chęć nauki nowego języka - rust zachęciła mnie do wyciągnięcia z szafy zakurzonej maliny i zbudowania bardziej złożonego układu.
Na początek skrócona lekcja elektroniki. Bardzo polecam dowolną pozycję z ćwiczeniami. Wiedza na temat tego co się dzieje i jak działa prąd zwiększy bezpieczeństwo (nasze i delikatnych układów scalonych) oraz zapewni dużo większą satysfakcję z całego procesu."></head><body><nav class="navbar navbar-expand-md navbar-light bg-light fixed-top shadow-sm" id=navbar-main-menu><div class=container><a class="navbar-brand font-weight-bold" href=https://flakm.github.io/>FlakM blog</a>
<button class=navbar-toggler type=button data-toggle=collapse data-target=#main-menu aria-controls=main-menu aria-expanded=false aria-label="Toggle navigation">
<span class=navbar-toggler-icon></span></button><div class="collapse navbar-collapse" id=main-menu><ul class="navbar-nav ml-auto"><li class=nav-item><a class=nav-link href=/>Home</a></li><li class=nav-item><a class=nav-link href=/about/>O mnie</a></li></ul></div></div></nav><main class="content-page container pt-7 pb-5"><div class=row><div class=col><article><div class="row justify-content-center"><div class=col-lg-8><h2 class=mb-3>Zardzewiała dioda</h2><div class=content><p>Przez ostatnie kilka lat zajmowałem się programowaniem aplikacji biznesowych.
Nigdy nie miałęm okazji uczestniczyć w lekcjach elektroniki.
Chęć nauki nowego języka - rust zachęciła mnie do wyciągnięcia z szafy zakurzonej maliny i zbudowania bardziej złożonego układu.</p><p>Na początek skrócona lekcja elektroniki.
Bardzo polecam dowolną pozycję z ćwiczeniami. Wiedza na temat tego co się dzieje i jak działa prąd zwiększy bezpieczeństwo (nasze i delikatnych układów scalonych) oraz zapewni dużo większą satysfakcję z całego procesu.</p><h2 id=zakupy-i-przygotowania>Zakupy i przygotowania&mldr;</h2><p>Na początek drobna lista zakupów:</p><ul><li>Raspberry pi (właściwie dowolny model, ja posiadam 2B)</li><li>karta pamięci zgodna z wymaganiami maliny</li><li>karta rozszerzeń GPIO</li><li>Taśma 40-pin do karty GPIO</li><li>płytka stykowa</li><li>przewody męsko męskie</li><li>dioda led</li><li>rezystor o odpowiedniej wartości w moim przypakdu 4,7kohm (potem zamieniony na 330)</li></ul><p>W pierwszej kolejności należy zadbać o to, żeby na karcie pamięci pojawił się zainstalowany aktualny system.
Można podejść do tego zgodnie z <a href=https://www.raspberrypi.org/documentation/installation/installing-images/>instrukcją producenta</a>.
Podstawowe dane logowania to <code>pi</code> i hasło <code>raspberry</code>. Za pierwszym razem musimy się zalogować przy użyciu wyjścia hdmi i klawiatury fizycznej.
Aby umożliwić wygodną dalszą pracę warto zadbać o możliwość zdalnego połączenia poprzez włączenie usługi ssh na malinie.
Wyczerpująca instrukcja jak przejść przez ten proces dostępna jest <a href=https://www.raspberrypi.org/documentation/remote-access/ssh/>tutaj</a>.</p><p>Dodatkowo zakładam, że kod napisany w rust będę uruchamiał na swoim laptopie z linuxem.
Możliwe jest wykonanie tego samego procesu używając dowolnego systemu a nawet na samej malinie.
Wybieram model pracy z kompilacją na swoim laptopie ze względu na czas kompilacji i obecność wszystkich wymaganych narzędzi.</p><p>Wymagane narzędzia do pracy z kodem w rust:</p><ul><li>narzędzia do kompilacji rust <a href=https://rustup.rs/>https://rustup.rs/</a></li><li>dowolny edytor tekstu, polecam VScode z wtyczką Rust Analyzer</li><li>ssh i scp do połączenia zdalnego i przesłania skompilowanego projektu</li></ul><h2 id=czas-zakasaćrękawy>Czas zakasać rękawy</h2><p>Do maliny podłączamy taśmę gpio jak na zdjęciu:</p><figure class="figure img-lg"><a href=/images/rystypi/leds/ta%c5%9bma.jpg class=d-block data-toggle=lightbox data-gallery=post-gallery><img src=/images/rystypi/leds/ta%c5%9bma.jpg class="figure-img img-fluid"></a></figure><p>A następnie taśmę do płytki rozszerzeń i zamontować ją na płytce stykowej.
Pełen układ jest widoczny poniżej:</p><figure class="figure img-lg"><a href=/images/rystypi/leds/uk%c5%82ad.jpg class=d-block data-toggle=lightbox data-gallery=post-gallery><img src=/images/rystypi/leds/uk%c5%82ad.jpg class="figure-img img-fluid"></a></figure><ul><li><strong>Pin GPIO23</strong> jest połączony czerwonym przewodem z szyną dodatnią</li><li><strong>PIN GND</strong> jest połączony z szyną ujemną</li><li>dioda LED (krótsza nóżka powinna być połączona z ujemną szyną)</li><li>rezystor o wartości 4,7Kohm</li><li>przewód zamykający obwód</li></ul><p>Aby przetestować układ możemy uruchomić skrypt (na malinie):</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>cat <span style=color:#e6db74>&lt;&lt;EOF &gt; led.py
</span><span style=color:#e6db74>from gpiozero import LED
</span><span style=color:#e6db74>
</span><span style=color:#e6db74>from time import sleep
</span><span style=color:#e6db74>
</span><span style=color:#e6db74>led = LED(23)
</span><span style=color:#e6db74>
</span><span style=color:#e6db74>while True:
</span><span style=color:#e6db74>   led.on()
</span><span style=color:#e6db74>   sleep(1)
</span><span style=color:#e6db74>   led.off()
</span><span style=color:#e6db74>   sleep(1)
</span><span style=color:#e6db74>EOF</span>
python led.py
</code></pre></div><p>Dioda powinna zacząć migać z przerwami 1 sekundy.
Aby przerwać program należy nacisnąć klawisze CTRL+C.
W tym momencie dioda przestanie się palić.</p><h2 id=ale-co-właściwie-sięstało>Ale co właściwie się stało?</h2><p>Aby zrozumieć co właściwie się dzieje można przeczytać kod źródłowy, <a href=https://www.raspberrypi.org/documentation/hardware/raspberrypi/bcm2835/BCM2835-ARM-Peripherals.pdf>dokumentację</a> albo&mldr; Hmmm, zaimplementować całość ręcznie w C (po raz pierwszy w życiu).</p><p>Wejście wyście ogólnego przeznaczenia - GPIO to cyfrowy interfejs komunikacji między elementami mikroprocesora a urządzeniami peryferyjnymi jak nasza dioda. Interfejs ten jest dostępny dla procesora jako zakres adresów w pamięci.</p><p>Istnieją dwa sposoby komunikacji:</p><ul><li><code>/dev/mem</code> (oraz bardziej bezpieczny <code>/dev/gpiomem</code>)</li><li><code>sysfs</code> - pseudo system plików dostarczany wraz z jądrem linuksa</li></ul><p>Ostatni sposób jest bardzo prosty i polega na manipulowaniu plikami:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>echo <span style=color:#ae81ff>23</span> &gt; /sys/class/gpio/export
echo out &gt; /sys/class/gpio/gpio23/direction 
echo <span style=color:#ae81ff>1</span> &gt; /sys/class/gpio/gpio23/value
echo <span style=color:#ae81ff>0</span> &gt; /sys/class/gpio/gpio23/value
</code></pre></div><p>Za zapalanie naszej diody odpowiada w tym przypadku kernel. Jednak wadą jest brak kontroli nad momentem wykonania operacji.
Nie ma to wielkiego znaczenia kiedy chcemy zapalać diodę LED, ale może mieć ogromne znaczenie, jeżeli nasze układy staną się bardziej złożone i zależne od czasu.</p><p>Aby sterować w naszym programie pinem GPIO użyjemy pierwszego sposobu przy użyciu pliku <code>/dev/gpiomem</code>. W pierwszej kolejnośći należy otworzyć jeden ze wskazanych plików i użyć wywołania systemowego <code>mmap</code> które spowoduje, że system odwzoruje ten plik w przestrzeni adresowej pamięci procesu.</p><p>Od tego momentu plik z perspektywy naszego programu wygląda jak zwykła tablica bajtów, nie musimy wykorzystywać innych wywołań systemowych do odczytu czy zapisu.</p><p>Ufff&mldr; Dużo gadania, ale czy ten super prosty skrypt pythonowy też musiał się tak męczyć?
Żeby to sprawdzić bez wczytywania się w dokumentację biblioteki czy kodu możemy wykorzystać system operacyjny.</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>pi@raspberrypi:~ $ python led.py 
^CTraceback <span style=color:#f92672>(</span>most recent call last<span style=color:#f92672>)</span>:
  File <span style=color:#e6db74>&#34;led.py&#34;</span>, line 11, in &lt;module&gt;
    sleep<span style=color:#f92672>(</span>1<span style=color:#f92672>)</span>
KeyboardInterrupt
closing _devices_shutdown
pi@raspberrypi:~ $ python led.py 
this is weird
^Z
<span style=color:#f92672>[</span>2<span style=color:#f92672>]</span>+  Zatrzymano              python led.py
pi@raspberrypi:~ $ lsof -p <span style=color:#66d9ef>$(</span>pidof python<span style=color:#66d9ef>)</span>
COMMAND  PID USER   FD   TYPE DEVICE SIZE/OFF   NODE NAME
python  <span style=color:#ae81ff>4178</span>   pi  cwd    DIR  179,2     <span style=color:#ae81ff>4096</span> <span style=color:#ae81ff>263116</span> /home/pi
python  <span style=color:#ae81ff>4178</span>   pi  rtd    DIR  179,2     <span style=color:#ae81ff>4096</span>      <span style=color:#ae81ff>2</span> /
python  <span style=color:#ae81ff>4178</span>   pi  txt    REG  179,2  <span style=color:#ae81ff>2984816</span> <span style=color:#ae81ff>271183</span> /usr/bin/python2.7
python  <span style=color:#ae81ff>4178</span>   pi  mem    REG  179,2    <span style=color:#ae81ff>42908</span>  <span style=color:#ae81ff>20121</span> /usr/lib/python2.7/dist-packages/RPi/_GPIO.arm-linux-gnueabihf.so
python  <span style=color:#ae81ff>4178</span>   pi  mem    REG  179,2  <span style=color:#ae81ff>3031504</span> <span style=color:#ae81ff>274369</span> /usr/lib/locale/locale-archive
python  <span style=color:#ae81ff>4178</span>   pi  mem    REG  179,2  <span style=color:#ae81ff>1296004</span>    <span style=color:#ae81ff>427</span> /lib/arm-linux-gnueabihf/libc-2.28.so
python  <span style=color:#ae81ff>4178</span>   pi  mem    REG  179,2   <span style=color:#ae81ff>464392</span>    <span style=color:#ae81ff>452</span> /lib/arm-linux-gnueabihf/libm-2.28.so
python  <span style=color:#ae81ff>4178</span>   pi  mem    REG  179,2   <span style=color:#ae81ff>108168</span>    <span style=color:#ae81ff>514</span> /lib/arm-linux-gnueabihf/libz.so.1.2.11
python  <span style=color:#ae81ff>4178</span>   pi  mem    REG  179,2     <span style=color:#ae81ff>9796</span>    <span style=color:#ae81ff>511</span> /lib/arm-linux-gnueabihf/libutil-2.28.so
python  <span style=color:#ae81ff>4178</span>   pi  mem    REG  179,2     <span style=color:#ae81ff>9768</span>    <span style=color:#ae81ff>435</span> /lib/arm-linux-gnueabihf/libdl-2.28.so
python  <span style=color:#ae81ff>4178</span>   pi  mem    REG  179,2   <span style=color:#ae81ff>130416</span>    <span style=color:#ae81ff>491</span> /lib/arm-linux-gnueabihf/libpthread-2.28.so
python  <span style=color:#ae81ff>4178</span>   pi  mem    REG  179,2    <span style=color:#ae81ff>19876</span>  <span style=color:#ae81ff>19899</span> /usr/lib/python2.7/dist-packages/spidev.arm-linux-gnueabihf.so
python  <span style=color:#ae81ff>4178</span>   pi  mem    REG  179,2    <span style=color:#ae81ff>17708</span> <span style=color:#ae81ff>272881</span> /usr/lib/arm-linux-gnueabihf/libarmmem-v7l.so
python  <span style=color:#ae81ff>4178</span>   pi  mem    REG  179,2   <span style=color:#ae81ff>138604</span>    <span style=color:#ae81ff>352</span> /lib/arm-linux-gnueabihf/ld-2.28.so
python  <span style=color:#ae81ff>4178</span>   pi  mem    CHR  247,0            <span style=color:#ae81ff>1116</span> /dev/gpiomem
python  <span style=color:#ae81ff>4178</span>   pi    0u   CHR  136,0      0t0      <span style=color:#ae81ff>3</span> /dev/pts/0
python  <span style=color:#ae81ff>4178</span>   pi    1u   CHR  136,0      0t0      <span style=color:#ae81ff>3</span> /dev/pts/0
python  <span style=color:#ae81ff>4178</span>   pi    2u   CHR  136,0      0t0      <span style=color:#ae81ff>3</span> /dev/pts/0
python  <span style=color:#ae81ff>4178</span>   pi    3u   CHR  247,0      0t0   <span style=color:#ae81ff>1116</span> /dev/gpiomem
</code></pre></div><p>Włączamy nasz skrypt i naciskamy CTRL+Z wstrzymując proces poprzez wysłanie sygnału <code>SIGSTOP</code>.
Następnie używając polecenia <code>lsof -p $(pidof python)</code> znajdujemy listę plików otwartych przez proces.
Ha! <code>/dev/gpiomem</code> znajduje się na liście!</p><p>W takim razie spróbujemy ręcznie używając C:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;stdio.h&gt;    // for printf</span><span style=color:#75715e>
</span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;fcntl.h&gt;    // for open</span><span style=color:#75715e>
</span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;sys/mman.h&gt; // for mmap</span><span style=color:#75715e>
</span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;unistd.h&gt;</span><span style=color:#75715e>
</span><span style=color:#75715e></span>
<span style=color:#75715e>#define GPCLR0 0x28
</span><span style=color:#75715e>#define GPSET0 0x1C
</span><span style=color:#75715e>#define GPLEV0 0x34
</span><span style=color:#75715e></span>
<span style=color:#75715e>/* 
</span><span style=color:#75715e>    Sprawdza stan pina o numerze 23, ustawia stan na wysoki po czym zmienia na niski
</span><span style=color:#75715e>
</span><span style=color:#75715e>    https://www.raspberrypi.org/documentation/hardware/raspberrypi/bcm2835/BCM2835-ARM-Peripherals.pdf
</span><span style=color:#75715e>    https://www.cs.uaf.edu/2016/fall/cs301/lecture/11_09_raspberry_pi.html
</span><span style=color:#75715e>    https://elinux.org/RPi_GPIO_Code_Samples
</span><span style=color:#75715e> */</span>
<span style=color:#66d9ef>int</span> <span style=color:#a6e22e>main</span>()
{
    <span style=color:#66d9ef>int</span> fd <span style=color:#f92672>=</span> open(<span style=color:#e6db74>&#34;/dev/gpiomem&#34;</span>, O_RDWR);
    <span style=color:#66d9ef>if</span> (fd <span style=color:#f92672>&lt;</span> <span style=color:#ae81ff>0</span>)
    {
        printf(<span style=color:#e6db74>&#34;Error opening /dev/gpiomem&#34;</span>);
        <span style=color:#66d9ef>return</span> <span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>;
    }

    <span style=color:#66d9ef>unsigned</span> <span style=color:#66d9ef>int</span> <span style=color:#f92672>*</span>gpio <span style=color:#f92672>=</span> (<span style=color:#66d9ef>unsigned</span> <span style=color:#66d9ef>int</span> <span style=color:#f92672>*</span>)mmap(<span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>4096</span>,
                                              PROT_READ <span style=color:#f92672>+</span> PROT_WRITE, MAP_SHARED,
                                              fd, <span style=color:#ae81ff>0</span>);

    <span style=color:#66d9ef>int</span> gpio_num <span style=color:#f92672>=</span> <span style=color:#ae81ff>23</span>;

    <span style=color:#75715e>// offset w bajtach pomiędzy kolejnymi elementami w tablicy
</span><span style=color:#75715e></span>    <span style=color:#75715e>// 32 bity = 8 * 4 bajty
</span><span style=color:#75715e></span>    <span style=color:#66d9ef>int</span> u32_offset <span style=color:#f92672>=</span> <span style=color:#ae81ff>4</span>;

    <span style=color:#66d9ef>int</span> FSEL_SHIFT <span style=color:#f92672>=</span> (gpio_num) <span style=color:#f92672>/</span> <span style=color:#ae81ff>10</span>;

    <span style=color:#75715e>// każdy pin ma przypisane 3 bity
</span><span style=color:#75715e></span>    <span style=color:#75715e>// 000 -&gt; input
</span><span style=color:#75715e></span>    <span style=color:#75715e>// 001 -&gt; output
</span><span style=color:#75715e></span>    <span style=color:#75715e>// 010 i wyżej -&gt; alternate functions (zależne od numeru pinu)
</span><span style=color:#75715e></span>    <span style=color:#75715e>//
</span><span style=color:#75715e></span>    <span style=color:#75715e>// więcej w rozdziale 6.2
</span><span style=color:#75715e></span>    gpio[FSEL_SHIFT] <span style=color:#f92672>&amp;=</span> <span style=color:#f92672>~</span>(<span style=color:#ae81ff>7</span> <span style=color:#f92672>&lt;&lt;</span> (((gpio_num) <span style=color:#f92672>%</span> <span style=color:#ae81ff>10</span>) <span style=color:#f92672>*</span> <span style=color:#ae81ff>3</span>)); <span style=color:#75715e>// zawsze przed ustawieniem na output musimy ustawić na input
</span><span style=color:#75715e></span>    gpio[FSEL_SHIFT] <span style=color:#f92672>|=</span> (<span style=color:#ae81ff>1</span> <span style=color:#f92672>&lt;&lt;</span> (((gpio_num) <span style=color:#f92672>%</span> <span style=color:#ae81ff>10</span>) <span style=color:#f92672>*</span> <span style=color:#ae81ff>3</span>));  <span style=color:#75715e>// output
</span><span style=color:#75715e></span>
    <span style=color:#75715e>// GPLEV0 piny 0 - 31, ten kod nie obsłuży pin &gt; 31
</span><span style=color:#75715e></span>    <span style=color:#75715e>// Odczytuje stan pina gpio_num poprzez odczytanie bitu gpio_num rejestru GPLEV0
</span><span style=color:#75715e></span>    <span style=color:#66d9ef>int</span> state <span style=color:#f92672>=</span> (gpio[GPLEV0 <span style=color:#f92672>/</span> u32_offset] <span style=color:#f92672>&gt;&gt;</span> gpio_num) <span style=color:#f92672>&amp;</span> <span style=color:#ae81ff>1</span>;
    printf(<span style=color:#e6db74>&#34;status is %i</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>, state);

    <span style=color:#66d9ef>while</span> (<span style=color:#ae81ff>1</span><span style=color:#f92672>==</span><span style=color:#ae81ff>1</span>)
    {
        sleep(<span style=color:#ae81ff>1</span>);

        gpio[GPSET0 <span style=color:#f92672>/</span> u32_offset] <span style=color:#f92672>|=</span> <span style=color:#ae81ff>1</span> <span style=color:#f92672>&lt;&lt;</span> gpio_num;
        printf(<span style=color:#e6db74>&#34;set to high</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>);

        sleep(<span style=color:#ae81ff>1</span>);

        gpio[GPCLR0 <span style=color:#f92672>/</span> u32_offset] <span style=color:#f92672>|=</span> <span style=color:#ae81ff>1</span> <span style=color:#f92672>&lt;&lt;</span> gpio_num;
        printf(<span style=color:#e6db74>&#34;set to low</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>);
    }

    <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>0</span>;
}

</code></pre></div><p>Układ scalony BCM2835 posiada 41 rejestrów, każdy z nich ma 32 bity. Aby mieć do nich dostęp w pierwszej kolejności otwieramy plik <code>/dev/gpiomem</code></p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=color:#66d9ef>int</span> fd <span style=color:#f92672>=</span> open(<span style=color:#e6db74>&#34;/dev/gpiomem&#34;</span>, O_RDWR);
</code></pre></div><p>Oraz używamy <code>mmap</code> aby mieć możliwość operowania na jego zawartości:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c>    <span style=color:#66d9ef>unsigned</span> <span style=color:#66d9ef>int</span> <span style=color:#f92672>*</span>gpio <span style=color:#f92672>=</span> (<span style=color:#66d9ef>unsigned</span> <span style=color:#66d9ef>int</span> <span style=color:#f92672>*</span>)mmap(<span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>4096</span>,
                                              PROT_READ <span style=color:#f92672>+</span> PROT_WRITE, MAP_SHARED,
                                              fd, <span style=color:#ae81ff>0</span>);

</code></pre></div><p>Zgodnie z dokumentacją aby odczytać stan danego pina (w naszym przypadku 23) należy odczytać odpowiedni bit rejestru <code>GPLEV0</code> który posiada adres <code>0x 7E20 0034</code> (offset <code>0x34</code>):</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=color:#66d9ef>int</span> state <span style=color:#f92672>=</span> (gpio[GPLEV0 <span style=color:#f92672>/</span> u32_offset] <span style=color:#f92672>&gt;&gt;</span> gpio_num) <span style=color:#f92672>&amp;</span> <span style=color:#ae81ff>1</span>;
</code></pre></div><p>Jeżeli chcemy zmienić stan danego pina musimy najpierw zmienić jego tryb na wyjściowy.
Zgodnie z dokumentacją każdy z 54 pinów posiada przynajmniej dwie funkcje.
Przykładowo, żeby ustawić tryb pracy pina 23 (a pozostałych na domyślną wartość 000) należy ustawić wartość rejestru <code>GPFSEL2</code> (rejestr dla pinów 20-29) na 001</p><p>00000000000000000000<strong>001</strong>000000000</p><p>W kodzie przed ustawieniem trybu wyjściowego najpierw ustawiam na tryb wejściowy podążając za poradami z przykładów.
Następnie aby ustawić wartość pina na wysoką należy ustawić odpowiedni bit w rejestrze <code>GPSET{n}</code> gdzie <code>n==0</code> dla pinów 0-31.</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c>gpio[GPSET0 <span style=color:#f92672>/</span> u32_offset] <span style=color:#f92672>|=</span> <span style=color:#ae81ff>1</span> <span style=color:#f92672>&lt;&lt;</span> gpio_num;
</code></pre></div><p>Aby zgasić naszą diodę należy ustawić odpowiedni bit innego rejestru: <code>GPCLR{n}</code> gdzie <code>n==0</code> dla pinów 0-31:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c>gpio[GPCLR0<span style=color:#f92672>/</span>u32_offset] <span style=color:#f92672>|=</span> <span style=color:#ae81ff>1</span> <span style=color:#f92672>&lt;&lt;</span> gpio_num;
</code></pre></div><p>Plik możemy skompilować na malinie używając bibliotek dostarczanych razem z systemem operacyjnym:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>pi@raspberrypi:~ $ gcc led.c -o led
pi@raspberrypi:~ $ ./led 
</code></pre></div><h2 id=co-jeżeli-nie-jestem-wielkim-fanem-c>Co jeżeli nie jestem wielkim fanem C?</h2><p>To już w sumie 3 różne sposoby na wykonywanie tej samej - mało potrzebnej czynności.
Co jeżeli manipulowanie plikami nam nie odpowiada, nie chcemy tracić zalet rozwiązania z C a języki interpretowane zachęcają nas tak samo jak głaskanie jeża pod włos? <strong>Pora na kolejną technologię!</strong></p><figure class="figure img-lg"><a href=/images/rystypi/leds/it-crowd-gif-4.gif class=d-block data-toggle=lightbox data-gallery=post-gallery><img src=/images/rystypi/leds/it-crowd-gif-4.gif class="figure-img img-fluid"></a></figure><p>Aby rozpocząć projekt na maszynie na której chcemy budować kod należy stworzyć nowy projekt:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=color:#75715e># tworzymy nowy projekt w katalogu rusty_led</span>
cargo new rusty_led --bin
cd rusty_led

<span style=color:#75715e># instalacja rustup powoduje zainstalowanie bibliotek dla naszego środowiska</span>
<span style=color:#75715e># aby zainstalować biblioteki dla raspberry pi należy wykonać polecenie:</span>
rustup target add armv7-unknown-linux-gnueabihf
<span style=color:#75715e># install arm linker</span>
<span style=color:#75715e># todo sprawdzić czy to jest potrzebne</span>
sudo apt-get install -qq gcc-arm-linux-gnueabihf
tree .
</code></pre></div><p>Musimy dodać w <code>~/.cargo/config</code> następującą treść:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>mkdir .cargo
cat <span style=color:#e6db74>&lt;&lt;EOF &gt; .cargo/config
</span><span style=color:#e6db74>[target.armv7-unknown-linux-gnueabihf]
</span><span style=color:#e6db74>linker = &#34;arm-linux-gnueabihf-gcc&#34;
</span><span style=color:#e6db74>EOF</span>
</code></pre></div><p>Następnie możemy uruchomić kompilację:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>cargo build --target armv7-unknown-linux-gnueabihf
</code></pre></div><p>Gotowy plik wykonywalny jest dostępny w pliku <code>target/armv7-unknown-linux-gnueabihf/debug/rusty_led</code>.
Aby go wykonać na malinie musimy go wysłać na malinę.
Zakładając, że znamy adres ip maliny (w moim przypadku <code>192.168.8.103</code>) oraz, że skonfigurowaliśmy odpowiednie klucze prywatne i publiczne możemy go przesłać używając polecenia:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=color:#75715e># przesyłamy plik</span>
scp target/armv7-unknown-linux-gnueabihf/debug/rusty_led pi@192.168.8.113:~/
<span style=color:#75715e># uruchamiamy skompilowany plik wykonywalny</span>
ssh pi@192.168.8.113 <span style=color:#e6db74>&#39;./rusty_led&#39;</span>

<span style=color:#75715e>#   output:</span>
<span style=color:#75715e>#   Hello, world!</span>
</code></pre></div><p>Teraz należy dodać zależność do biblioteki która umożliwi nam używanie GPIO.
Zeby to zrobić starczy dopisać do pliku <code>Cargo.toml</code> w sekcji <code>[dependencies]</code>:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-toml data-lang=toml><span style=color:#a6e22e>rppal</span> = <span style=color:#e6db74>&#34;0.11.3&#34;</span>
</code></pre></div><p>A treść pliku <code>main.rs</code> zamienić:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=color:#66d9ef>use</span> std::error::Error;
<span style=color:#66d9ef>use</span> std::thread;
<span style=color:#66d9ef>use</span> std::time::Duration;

<span style=color:#66d9ef>use</span> rppal::gpio::Gpio;
<span style=color:#66d9ef>use</span> rppal::system::DeviceInfo;

<span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>main</span>() -&gt; Result<span style=color:#f92672>&lt;</span>(), Box<span style=color:#f92672>&lt;</span>dyn Error<span style=color:#f92672>&gt;&gt;</span> {
    println<span style=color:#f92672>!</span>(<span style=color:#e6db74>&#34;Działam na {}.&#34;</span>, DeviceInfo::new()<span style=color:#f92672>?</span>.model());

    <span style=color:#66d9ef>let</span> <span style=color:#66d9ef>mut</span> pin <span style=color:#f92672>=</span> Gpio::new()<span style=color:#f92672>?</span>.get(<span style=color:#ae81ff>23</span>)<span style=color:#f92672>?</span>.into_output();
    pin.set_reset_on_drop(<span style=color:#66d9ef>true</span>);

    <span style=color:#66d9ef>loop</span> {
        pin.set_high();
        thread::sleep(Duration::from_millis(<span style=color:#ae81ff>500</span>));
        pin.set_low();
        thread::sleep(Duration::from_millis(<span style=color:#ae81ff>500</span>));
    }

    Ok(())
}
</code></pre></div><p>Po skompilowaniu, przesłaniu i wykonaniu programu na malinie osiągamy analogiczny efekt do kodu z pythona i C.
Jeżeli zaglądniemy dokładniej w kod źródłowy biblioteki rppal to zauważymy pewne podobieństwa do programu, który napisaliśmy w C:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust>    <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>map_devgpiomem</span>() -&gt; Result<span style=color:#f92672>&lt;*</span><span style=color:#66d9ef>mut</span> <span style=color:#66d9ef>u32</span><span style=color:#f92672>&gt;</span> {
        <span style=color:#75715e>// Open /dev/gpiomem with read/write/sync flags. This might fail if
</span><span style=color:#75715e></span>        <span style=color:#75715e>// /dev/gpiomem doesn&#39;t exist (&lt; Raspbian Jessie), or /dev/gpiomem
</span><span style=color:#75715e></span>        <span style=color:#75715e>// doesn&#39;t have the appropriate permissions, or the current user is
</span><span style=color:#75715e></span>        <span style=color:#75715e>// not a member of the gpio group.
</span><span style=color:#75715e></span>        <span style=color:#66d9ef>let</span> gpiomem_file <span style=color:#f92672>=</span> OpenOptions::new()
            .read(<span style=color:#66d9ef>true</span>)
            .write(<span style=color:#66d9ef>true</span>)
            .custom_flags(O_SYNC)
            .open(PATH_DEV_GPIOMEM)<span style=color:#f92672>?</span>;

        <span style=color:#75715e>// Memory-map /dev/gpiomem at offset 0
</span><span style=color:#75715e></span>        <span style=color:#66d9ef>let</span> gpiomem_ptr <span style=color:#f92672>=</span> <span style=color:#66d9ef>unsafe</span> {
            libc::mmap(
                ptr::null_mut(),
                GPIO_MEM_SIZE,
                PROT_READ <span style=color:#f92672>|</span> PROT_WRITE,
                MAP_SHARED,
                gpiomem_file.as_raw_fd(),
                <span style=color:#ae81ff>0</span>,
            )
        };

        <span style=color:#66d9ef>if</span> gpiomem_ptr <span style=color:#f92672>==</span> MAP_FAILED {
            <span style=color:#66d9ef>return</span> Err(Error::Io(io::Error::last_os_error()));
        }

        Ok(gpiomem_ptr <span style=color:#66d9ef>as</span> <span style=color:#f92672>*</span><span style=color:#66d9ef>mut</span> <span style=color:#66d9ef>u32</span>)
    }
</code></pre></div><p>Hmmm pomijając o wiele ładniejszą kontrolę błędów kod jest właściwie taki sam! Wykorzystuje crate (biblioteka w środowisku rusta) <code>libc</code> do wywołania w bloku <code>unsafe</code> tego samego wywołania systemowego. Podobnie jest w przypadku pozostałych fragmentów, przykładowo ustawienia wartości pin:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust>    <span style=color:#66d9ef>const</span> GPSET0: <span style=color:#66d9ef>usize</span> <span style=color:#f92672>=</span> <span style=color:#ae81ff>0x1c</span> <span style=color:#f92672>/</span> std::mem::size_of::<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>u32</span><span style=color:#f92672>&gt;</span>();

    <span style=color:#75715e>// some parts omitted
</span><span style=color:#75715e></span>
    <span style=color:#66d9ef>pub</span>(<span style=color:#66d9ef>crate</span>) <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>set_high</span>(<span style=color:#f92672>&amp;</span>self, pin: <span style=color:#66d9ef>u8</span>) {
        <span style=color:#66d9ef>let</span> offset <span style=color:#f92672>=</span> GPSET0 <span style=color:#f92672>+</span> pin <span style=color:#66d9ef>as</span> <span style=color:#66d9ef>usize</span> <span style=color:#f92672>/</span> <span style=color:#ae81ff>32</span>;
        <span style=color:#66d9ef>let</span> shift <span style=color:#f92672>=</span> pin <span style=color:#f92672>%</span> <span style=color:#ae81ff>32</span>;
        self.write(offset, <span style=color:#ae81ff>1</span> <span style=color:#f92672>&lt;&lt;</span> shift);
    }
</code></pre></div><p>Jest jeden problem, zachowanie naszego układu elektronicznego po wyjściu z programu jest niedeterministyczne (podobnie jak w przypadku programu w C). Przez wyjście mam na myśli naciśnięcie CTRL+C czyli wysłanie sygnału <code>SIGINT</code>.
Obydwa programy (C i rust) nie czyszczą w żaden sposób stanu, dioda zostaje włączona jeżeli w momencie wysłania sygnału była właśnie w takim stanie.</p><p>Czemu tak jest? Jedynie biblioteka w pythonie którą używaliśmy posiada taką funkcjonalność.
Fragment kodu który za nią odpowiada można znaleźć w pliku <code>devices.py</code></p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>_devices_shutdown</span>():
    <span style=color:#66d9ef>if</span> Device<span style=color:#f92672>.</span>pin_factory <span style=color:#f92672>is</span> <span style=color:#f92672>not</span> None:
        <span style=color:#66d9ef>with</span> Device<span style=color:#f92672>.</span>pin_factory<span style=color:#f92672>.</span>_res_lock:
            reserved_devices <span style=color:#f92672>=</span> {
                dev
                <span style=color:#66d9ef>for</span> ref_list <span style=color:#f92672>in</span> Device<span style=color:#f92672>.</span>pin_factory<span style=color:#f92672>.</span>_reservations<span style=color:#f92672>.</span>values()
                <span style=color:#66d9ef>for</span> ref <span style=color:#f92672>in</span> ref_list
                <span style=color:#66d9ef>for</span> dev <span style=color:#f92672>in</span> (ref(),)
                <span style=color:#66d9ef>if</span> dev <span style=color:#f92672>is</span> <span style=color:#f92672>not</span> None
            }
        <span style=color:#66d9ef>for</span> dev <span style=color:#f92672>in</span> reserved_devices:
            dev<span style=color:#f92672>.</span>close()
        Device<span style=color:#f92672>.</span>pin_factory<span style=color:#f92672>.</span>close()
        Device<span style=color:#f92672>.</span>pin_factory <span style=color:#f92672>=</span> None
</code></pre></div><p>Bardzo sympatyczna funkcjonalność tylko co jeżeli jej nie chcemy?
Okazuje się, że nie jest to łatwe, o czym można poczytać <a href=https://github.com/gpiozero/gpiozero/issues/707>tu</a> czy <a href=https://stackoverflow.com/questions/53618198/>tu</a>.</p><p>Co jednak jeżeli chcemy dodać podobną funkcjonalność do naszego nowego kodu w rust?
Zgodnie z dokumentacją crate <a href=https://docs.rs/rppal/0.11.3/rppal/gpio/index.html#pins>rppal</a> pin powinien zostać przywrócony do stanu oryginalnego w momencie kiedy zgodnie z zasadami własności obiekt zostaje porzucony. Ale co właściwie oznacza porzucenie?</p><p>Rust posiada innowacyjne podejście do zarządzania pamięcią poprzez wprowadzenie modelu własności.
Zarządzanie pamięcią nie jest jak w przypadku C czy C++ zarządzane ręcznie przez programistę, czy jak w javie czy go przez osobny obiekt nazywany garbage collection. O momencie zwalniania pamięci decyduje zestaw reguł, które kompilator częsciowo jest w stanie wywnioskować sam na podstawie ogólnych zasad lub z użyciem parametrów przekazywanych przez programistę w nieoczywistych przypadkach.</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=color:#66d9ef>use</span> std::thread;
<span style=color:#66d9ef>use</span> std::time::Duration;

<span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>HasDrop</span>{
    <span style=color:#66d9ef>pub</span> name: <span style=color:#66d9ef>u32</span>
}

<span style=color:#75715e>// 
</span><span style=color:#75715e></span><span style=color:#66d9ef>impl</span> Drop <span style=color:#66d9ef>for</span> HasDrop {
    <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>drop</span>(<span style=color:#f92672>&amp;</span><span style=color:#66d9ef>mut</span> self) {
        println<span style=color:#f92672>!</span>(<span style=color:#e6db74>&#34;Dropping {}&#34;</span>, self.name);
    }
}

<span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>main</span>() {
    {
        <span style=color:#66d9ef>let</span> _x <span style=color:#f92672>=</span> HasDrop{name: <span style=color:#ae81ff>1</span>};
    } <span style=color:#75715e>// _x zostaje porzucone w tym miejscu
</span><span style=color:#75715e></span>    <span style=color:#66d9ef>let</span> _y <span style=color:#f92672>=</span> HasDrop{name: <span style=color:#ae81ff>2</span>};
    thread::sleep(Duration::from_millis(<span style=color:#ae81ff>5000</span>));
} <span style=color:#75715e>// _ y w tym miejscu jeżeli wcześniej nie wysłany zostanie SIGINT
</span></code></pre></div><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>$ cargo -q run --example drop
Dropping <span style=color:#ae81ff>1</span>
Dropping <span style=color:#ae81ff>2</span>
$ cargo -q run --example drop
Dropping <span style=color:#ae81ff>1</span>
^C
<span style=color:#75715e># po uzyskaniu SIGINT brak wpisu o wykonaniu metody drop na y</span>
</code></pre></div><p>Model ten daje ogromne korzyści i może być wykorzystywana również do ciekawych zastosowań, jak na przykład oddawanie połączenia do bazy danych do pooli po jego wykorzystaniu bez pisania niepotrzebnego kodu.
W ten sam sposób zorganizowane jest przywracanie stanu oryginalnego dla pinów w rppal:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust>            <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>drop</span>(<span style=color:#f92672>&amp;</span><span style=color:#66d9ef>mut</span> self) {
                <span style=color:#66d9ef>if</span> <span style=color:#f92672>!</span>self.reset_on_drop {
                    <span style=color:#66d9ef>return</span>;
                }

                <span style=color:#66d9ef>if</span> <span style=color:#66d9ef>let</span> Some(prev_mode) <span style=color:#f92672>=</span> self.prev_mode {
                    self.pin.set_mode(prev_mode);
                }

                <span style=color:#66d9ef>if</span> self.pud_mode <span style=color:#f92672>!=</span> PullUpDown::Off {
                    self.pin.set_pullupdown(PullUpDown::Off);
                }
            }
</code></pre></div><p>Jednak jak udowodniliśmy wyżej metoda drop nie jest wołana w sytuacji kiedy przyczyną wyjścia z programu był sygnał <code>SIGINT</code>.
Czy jesteśmy w stanie coś z tym zrobić? Zgodnie z sugestią autora biblioteki musimy ręcznie obsłużyć odpowiedni sygnał. W pierwszej kolejności dodajemy nową bibliotekę do Cargo.toml:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-toml data-lang=toml><span style=color:#a6e22e>ctrlc</span> = <span style=color:#e6db74>&#34;3.1.4&#34;</span>
</code></pre></div><p>A następnie modyfikujemy nasz program:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=color:#66d9ef>use</span> std::error::Error;
<span style=color:#66d9ef>use</span> std::thread;
<span style=color:#66d9ef>use</span> std::time::Duration;

<span style=color:#66d9ef>use</span> rppal::gpio::Gpio;
<span style=color:#66d9ef>use</span> rppal::system::DeviceInfo;

<span style=color:#66d9ef>use</span> std::sync::{Arc, Mutex};

<span style=color:#75715e>//https://docs.golemparts.com/rppal/0.11.2/rppal/gpio/struct.OutputPin.html#note
</span><span style=color:#75715e></span>
<span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>main</span>() -&gt; Result<span style=color:#f92672>&lt;</span>(), Box<span style=color:#f92672>&lt;</span>dyn Error<span style=color:#f92672>&gt;&gt;</span> {
    println<span style=color:#f92672>!</span>(<span style=color:#e6db74>&#34;Działam na {}.&#34;</span>, DeviceInfo::new()<span style=color:#f92672>?</span>.model());

    <span style=color:#66d9ef>let</span> <span style=color:#66d9ef>mut</span> pin <span style=color:#f92672>=</span> Gpio::new()<span style=color:#f92672>?</span>.get(<span style=color:#ae81ff>23</span>)<span style=color:#f92672>?</span>.into_output();
    <span style=color:#66d9ef>let</span> closed <span style=color:#f92672>=</span> Arc::new(Mutex::new(<span style=color:#66d9ef>false</span>));

    <span style=color:#66d9ef>let</span> closed_handler <span style=color:#f92672>=</span> closed.clone();
    ctrlc::set_handler(<span style=color:#66d9ef>move</span> <span style=color:#f92672>||</span> {
        println<span style=color:#f92672>!</span>(<span style=color:#e6db74>&#34;received Ctrl+C!&#34;</span>);
        println<span style=color:#f92672>!</span>(<span style=color:#e6db74>&#34;set to closed&#34;</span>);
        <span style=color:#f92672>*</span>closed_handler.lock().unwrap() <span style=color:#f92672>=</span> <span style=color:#66d9ef>true</span>;
    })<span style=color:#f92672>?</span>;

    <span style=color:#66d9ef>while</span> <span style=color:#f92672>!*</span>closed.lock().unwrap() {
        pin.set_high();
        thread::sleep(Duration::from_millis(<span style=color:#ae81ff>500</span>));
        pin.set_low();
        thread::sleep(Duration::from_millis(<span style=color:#ae81ff>500</span>));
    }

    println<span style=color:#f92672>!</span>(<span style=color:#e6db74>&#34;setting to low&#34;</span>);
    pin.set_low();
    Ok(())
}
</code></pre></div><p>Dodaliśmy zmienną <code>closed</code> zabezpieczoną <code>Arc</code> - mądrym wskaźnikiem pozwalającym na dzielenie fragmentu pamięci pomiędzy wątkami i <code>Mutex</code> który zabezpiecza do niego dostęp. Czemu nie dodamy po prostu ustawienia stanu pina na niski w handlerze sygnału?</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust>    ctrlc::set_handler(<span style=color:#66d9ef>move</span> <span style=color:#f92672>||</span> {
        println<span style=color:#f92672>!</span>(<span style=color:#e6db74>&#34;received Ctrl+C!&#34;</span>);
        pin.set_low();
    })<span style=color:#f92672>?</span>;
</code></pre></div><p>Odpowiedź brzmi ponieważ kompilator rusta nam na to nie pozwoli. Otrzymamy błąd:</p><pre><code>error[E0382]: borrow of moved value: `pin`
  --&gt; src/main.rs:26:9
   |
15 |     let mut pin = Gpio::new()?.get(23)?.into_output();
   |         ------- move occurs because `pin` has type `rppal::gpio::pin::OutputPin`, which does not implement the `Copy` trait
...
19 |     ctrlc::set_handler(move || {
   |                        ------- value moved into closure here
...
22 |         pin.set_low();
   |         --- variable moved due to use in closure
...
26 |         pin.set_high();
   |         ^^^ value borrowed here after move

error: aborting due to 2 previous errors
</code></pre><p>Czyli zadziałają zasady własności które ochronią nas przed błędem, który nie zostałby wychwycony w analogicznym kodzie w C. Na czym polega błąd? Kod wykonywany po otrzymaniu sygnału <code>SIGINT</code> jest wykonywany w innym wątku niż pętla <code>while</code>
co oznacza, że potencjalnie wystąpiłby wyścig i zachowanie programu mogło by być różne.</p><h2 id=wnioski>Wnioski</h2><p>Nauczyliśmy się w jaki sposób można sterować pinami maliny oraz wielu sposobów zapalania diody LED.
Z moich doświadczeń z budowania tak prostego ukłądu wynika, że potrzebna jest duża uwaga, żeby nie popełnić błędu.
Łatwiej jest znaleźć i rozwiązać błąd jeżeli taki się pojawi w prostszym układzie.
Wraz ze zwiększaniem się rozmiarów kodu sterującego coraz bardziej zaawansowanymi układami prawdopodobieństwo błędów się powiększa.</p><p>Dlatego w mojej ocenie używanie narzędzi jak rust ma ogromną przewagę nad C, w którym brakuje silnego typowania oraz obsługi błędów. Po drugiej stronie jest python, który bardzo pasuje do maliny, natomiast jego użyteczność zmniejsza się na mniejszych układach, gdzie dostępna pamięć jest zdecydowanie większym ograniczneniem.</p></div></div></div></article></div></div></main><footer class="footer text-center bg-dark py-6"><div class=container><div class=row><div class=col><ul class=list-inline><li class=list-inline-item><a href=https://flakm.github.io/index.xml rel=alternate type=application/rss+xml class="icons d-block"><span class="fa-stack fa-lg"><i class="fa fa-circle fa-stack-2x"></i><i class="fa fa-rss fa-stack-1x fa-inverse"></i></span></a></li><li class=list-inline-item><a href=mailto:maciej.jan.flak@gmail.com class="icons d-block"><span class="fa-stack fa-lg"><i class="fa fa-circle fa-stack-2x"></i><i class="fa fa-envelope fa-stack-1x fa-inverse"></i></span></a></li><li class=list-inline-item><a href=https://github.com/FlakM class="icons d-block"><span class="fa-stack fa-lg"><i class="fa fa-circle fa-stack-2x"></i><i class="fab fa-github fa-stack-1x fa-inverse"></i></span></a></li><li class=list-inline-item><a href=https://twitter.com/FlakMaciej class="icons d-block"><span class="fa-stack fa-lg"><i class="fa fa-circle fa-stack-2x"></i><i class="fab fa-twitter fa-stack-1x fa-inverse"></i></span></a></li></ul><p class=text-muted>Copyright © 2020, Maciej Flak; all rights reserved.</p><p class=text-muted>Powered by <a href=https://gohugo.io target=_blank>Hugo</a> with <a href=https://github.com/puresyntax71/hugo-theme-chunky-poster target=_blank>Chunky Poster</a>.</p></div></div></div></footer><script src=/dist/main.d608eadfe5ac0688902e.min.js></script><script>window.Prism=window.Prism||{};window.Prism.manual=true;</script><script src=https://cdnjs.cloudflare.com/ajax/libs/prism/1.17.1/components/prism-core.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/prism/1.17.1/plugins/autoloader/prism-autoloader.min.js></script><script type=application/javascript>var doNotTrack=false;if(!doNotTrack){(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');ga('create','UA-172669006-1','auto');ga('send','pageview');}</script></body></html>